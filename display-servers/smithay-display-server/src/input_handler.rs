use smithay::{
    backend::input::{Event, InputBackend, PointerMotionEvent},
    input::pointer::{MotionEvent, RelativeMotionEvent},
    utils::{Logical, Point, SERIAL_COUNTER},
};

use crate::{managed_window::ManagedWindow, state::SmithayState};

impl SmithayState {
    pub fn on_pointer_move<B: InputBackend>(&mut self, event: B::PointerMotionEvent) {
        let serial = SERIAL_COUNTER.next_serial();
        self.pointer_location += event.delta();

        // clamp to screen limits
        // this event is never generated by winit
        self.pointer_location = self.clamp_coords(self.pointer_location);
        self.focus_window_under();

        let under = self.surface_under();

        if let Some(ptr) = self.seat.get_pointer() {
            ptr.motion(
                self,
                under.clone(),
                &MotionEvent {
                    location: self.pointer_location,
                    serial,
                    time: event.time_msec(),
                },
            );

            ptr.relative_motion(
                self,
                under,
                &RelativeMotionEvent {
                    delta: event.delta(),
                    delta_unaccel: event.delta_unaccel(),
                    utime: event.time(),
                },
            )
        }
    }

    fn clamp_coords(&self, pos: Point<f64, Logical>) -> Point<f64, Logical> {
        if self.space.outputs().next().is_none() {
            return pos;
        }

        let (pos_x, pos_y) = pos.into();
        let max_x = self.space.outputs().fold(0, |acc, o| {
            acc + self.space.output_geometry(o).unwrap().size.w
        });
        let clamped_x = pos_x.max(0.0).min(max_x as f64);
        let max_y = self
            .space
            .outputs()
            .find(|o| {
                let geo = self.space.output_geometry(o).unwrap();
                geo.contains((clamped_x as i32, 0))
            })
            .map(|o| self.space.output_geometry(o).unwrap().size.h);

        if let Some(max_y) = max_y {
            let clamped_y = pos_y.max(0.0).min(max_y as f64);
            (clamped_x, clamped_y).into()
        } else {
            (clamped_x, pos_y).into()
        }
    }

    pub fn surface_under(&self) -> Option<(ManagedWindow, Point<i32, Logical>)> {
        let pos = self.pointer_location;
        // let output = self.space.outputs().find(|o| {
        // let geometry = self.space.output_geometry(o).unwrap();
        // geometry.contains(pos.to_i32_round())
        // })?;
        // let output_geo = self.space.output_geometry(output).unwrap();
        // let layers = layer_map_for_output(output);

        let mut under = None;
        // if let Some(window) = output
        //     .user_data()
        //     .get::<FullscreenSurface>()
        //     .and_then(|f| f.get())
        // {
        //     under = Some((window.into(), output_geo.loc));
        // } else if let Some(layer) = layers
        //     .layer_under(WlrLayer::Overlay, pos)
        //     .or_else(|| layers.layer_under(WlrLayer::Top, pos))
        // {
        //     let layer_loc = layers.layer_geometry(layer).unwrap().loc;
        //     under = Some((layer.clone().into(), output_geo.loc + layer_loc))
        // } else if let Some((window, location)) = self.space.element_under(pos) {
        //     under = Some((window.clone().into(), location));
        // } else if let Some(layer) = layers
        //     .layer_under(WlrLayer::Bottom, pos)
        //     .or_else(|| layers.layer_under(WlrLayer::Background, pos))
        // {
        //     let layer_loc = layers.layer_geometry(layer).unwrap().loc;
        //     under = Some((layer.clone().into(), output_geo.loc + layer_loc));
        // };
        if let Some((window, location)) = self.space.element_under(pos) {
            under = Some((window.clone().into(), location))
        }

        under
    }
}
